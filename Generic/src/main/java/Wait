-> Waits <-

Waiting is having the automated task execution elapse a certain amount of time
before continuing with the next step.

To overcome the problem of race conditions between the browser and your WebDriver script,
most Selenium clients ship with a wait package. When employing a wait, you are using what is
commonly referred to as an explicit wait.

------------------------------------------------------------------------------------------------------
-> Explicit Wait <-

Explicit waits allow you to wait for a condition to occur.
It allows your code to halt program execution, or freeze the thread, until the condition you pass
it resolves. The condition is called with a certain frequency until the timeout of the wait is elapsed.
This means that for as long as the condition returns a false value, it will keep trying and waiting.

-> Example of Explicit Wait <-

WebDriver driver = new ChromeDriver(); <- create object of a new driver

driver.get("https://google.com/"); <- open up to google.com

driver.findElement(By.name("example")).sendKeys("text" + Keys.ENTER); <- finds and sends key to element & enter

// Initialize and wait till element(link) became clickable - timeout in 10 seconds
WebElement firstResult = new WebDriverWait(driver, Duration.ofSeconds(10))
        .until(ExpectedConditions.elementToBeClickable(By.xpath("//a/h3")));

// Print the first result
System.out.println(firstResult.getText());

We pass in the condition as a function reference that the wait will run repeatedly until its return
value is truthy. A “truthful” return value is anything that evaluates to boolean true in the
language at hand, such as a string, number, a boolean, an object (including a WebElement),
or a populated (non-empty) sequence or list. That means an empty list evaluates to false.
When the condition is truthful and the blocking wait is aborted, the return value from the
condition becomes the return value of the wait.

With this knowledge, and because the wait utility ignores no such element errors by default,
we can refactor our instructions to be more concise:


WebElement foo = new WebDriverWait(driver, Duration.ofSeconds(3))
          .until(driver -> driver.findElement(By.name("q")));
assertEquals(foo.getText(), "Hello from JavaScript!");


In that example, we pass in an anonymous function (but we could also define it explicitly as we did earlier so it may be reused). The first and only argument that is passed to our condition is always a reference to our driver object, WebDriver. In a multi-threaded environment, you should be careful to operate on the driver reference passed in to the condition rather than the reference to the driver in the outer scope.

Because the wait will swallow no such element errors that are raised when the element is not found, the condition will retry until the element is found. Then it will take the return value, a WebElement, and pass it back through to our script.

If the condition fails, e.g. a truthful return value from the condition is never reached, the wait will throw/raise an error/exception called a timeout error.

--------------------------------------------------------------------------------------------------------
-> Options <-

The wait condition can be customised to match your needs.
Sometimes it is unnecessary to wait the full extent of the default timeout,
as the penalty for not hitting a successful condition can be expensive.

The wait lets you pass in an argument to override the timeout:


new WebDriverWait(driver, Duration.ofSeconds(3)).until(ExpectedConditions.elementToBeClickable(By.xpath("//a/h3")));

--------------------------------------------------------------------------------------------------------
-> Expected conditions <-

Because it is quite a common occurrence to have to synchronise the DOM and your instructions,
most clients also come with a set of predefined expected conditions.
As might be obvious by the name, they are conditions that are predefined for frequent wait operations.

The conditions available in the different language bindings vary, but this is a non-exhaustive list of a few:

alert is present
element exists
element is visible
title contains
title is
element staleness
visible text

------------------------------------------------------------------------------------------------------
-> Implicit Wait <-

There is a second type of wait that is distinct from explicit wait called implicit wait. By implicitly waiting, WebDriver polls the DOM for a certain duration when trying to find any element. This can be useful when certain elements on the webpage are not available immediately and need some time to load.

Implicit waiting for elements to appear is disabled by default and will need to be manually enabled on a per-session basis. Mixing explicit waits and implicit waits will cause unintended consequences, namely waits sleeping for the maximum time even if the element is available or condition is true.

Warning: Do not mix implicit and explicit waits. Doing so can cause unpredictable wait times. For example, setting an implicit wait of 10 seconds and an explicit wait of 15 seconds could cause a timeout to occur after 20 seconds.

An implicit wait is to tell WebDriver to poll the DOM for a certain amount of time when trying to find an element or elements if they are not immediately available. The default setting is 0, meaning disabled. Once set, the implicit wait is set for the life of the session.


WebDriver driver = new FirefoxDriver();
driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);
driver.get("http://somedomain/url_that_delays_loading");
WebElement myDynamicElement = driver.findElement(By.id("myDynamicElement"));

------------------------------------------------------------------------------------------------------
-> Fluent Wait<-

FluentWait instance defines the maximum amount of time to wait for a condition, as well as the frequency with which to check the condition.

Users may configure the wait to ignore specific types of exceptions whilst waiting, such as NoSuchElementException when searching for an element on the page.


// Waiting 30 seconds for an element to be present on the page, checking
// for its presence once every 5 seconds.

Wait<WebDriver> wait = new FluentWait<WebDriver>(driver)
  .withTimeout(Duration.ofSeconds(30))
  .pollingEvery(Duration.ofSeconds(5))
  .ignoring(NoSuchElementException.class);

WebElement foo = wait.until(new Function<WebDriver, WebElement>() {
  public WebElement apply(WebDriver driver) {
    return driver.findElement(By.id("foo"));
  }
});

------------------------------------------------------------------------------------------------------